<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kanban Board - Keyboard Shortcuts & Enhanced UI</title>
<link rel="manifest" href="manifest.json" />
<meta name="theme-color" content="#3399ff" />
<style>
  :root {
    --bg: #23242a;
    --card: #282934;
    --input: #25293c;
    --highlight: #3399ff;
    --text: #f4f7fa;
    --shadow: 0 4px 22px #112 35%;
    --accent-high: #e74c3c;
    --accent-medium: #f39c12;
    --accent-low: #2ecc71;
    --tag: #236bdd;
    --blue: #1d8bf1;
    --rounded: 13px;
    --task-gradient: linear-gradient(135deg, #293040 65%, #1d2130 100%);
  }
  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--text);
    font-family: 'Segoe UI',Tahoma,Verdana,sans-serif; min-height:100vh;
  }
  .header-row {
    display: flex; justify-content: space-between; align-items: center;
    margin: 24px auto 7px auto; width: 98vw;
    min-height: 54px; padding:0 0 10px 0;
    gap:22px;
  }
  .search-box{
    margin-left:12px;
    min-width:210px;
    flex:0 0 220px;
    display: flex; align-items: center;
  }
  .search-box input {
    background: var(--input);
    border-radius:8px;
    border:1.2px solid #347aac;
    color: #f6fafe;
    outline:none;
    font-size:1em;
    padding:7px 10px;
    width:190px;
    box-shadow:0 2px 7px #2336;
    margin-left:5px;
  }
  .search-box input:focus { border-color: var(--highlight);}
  .top-controls { display:flex; gap:9px; align-items:center;}
  .mini-btn {
    background: #23293d;
    color: #fff;
    padding: 7px 13px;
    border: none;
    border-radius: 7px;
    font-size: 1.01em;
    font-weight: 600;
    box-shadow: 0 2px 8px #1a213387;
    transition: background .13s,transform .18s;
    cursor: pointer;
    min-width: 36px;
    position: relative;
    outline: none;
    display:flex;align-items:center;justify-content:center;
  }
  .mini-btn:hover { background: var(--blue); color: #fff; transform:translateY(-2px);}
  .mini-btn[title]:hover:after {
    content: attr(title);
    position:absolute; bottom:-35px; left:50%;transform:translateX(-50%);
    background: #111e2d; color:#ffc95c; font-size:.93em; padding:2.5px 9px;border-radius:6px;pointer-events:none;white-space:nowrap;z-index:5;
    border:1.5px solid #3477c7;
  }
  .mini-btn svg {width:18px;height:18px;display:block;}
  .board-title-wrap { flex:1; text-align:center;}
  h1 { font-size:2.1em;margin:0 0 7px 0;letter-spacing:1px;color:var(--highlight); font-weight:700; }
  .kanban-wrap { width:98vw;max-width:1330px;margin:0 auto 1em auto;display:flex;flex-direction:column;align-items:center;position:relative;}
  .task-form-container { width:100%;max-width:720px;position:relative;margin-bottom:16px;}
  .task-form-container[hidden] {display:none;}
  form {
    background: var(--card);
    border-radius: var(--rounded);
    box-shadow: var(--shadow);
    width:100%;
    margin:0 auto;
    padding:13px 12px 9px 12px;
    display:flex;gap:9px 0;flex-wrap:wrap;align-items: flex-end;justify-content:flex-start;
    position: relative;
  }
  .kanban-wrap label { font-size:0.93em;color:#aab3c6;display:block;margin-bottom:1.5px;}
  input[type="text"], textarea, select {
    background: var(--input);
    border-radius: 6px;
    border: 1.2px solid #1a2233;
    color: var(--text);
    outline: none;
    font-size: 1.01em;
    padding: 4.5px 8px;
    box-shadow: none;
    margin-bottom: 7px;
    transition: border-color .2s;
    min-width:115px;
    max-width:220px;
  }
  textarea { resize:vertical; min-width:85px; min-height:22px; max-width:95vw;}
  .form-group { display:flex;flex-direction:column;margin:0 4px 0 0;}
  .add-btn-inner { background:var(--blue); color:#fff; box-shadow:0 3px 10px #1a2851c6; padding:6px 11px;font-weight:600;font-size:1em;
    border-radius:7px;border:none;transition:background .13s,transform .11s;cursor:pointer;}
  .add-btn-inner:hover { background: #1381e6; color:#fff; transform:translateY(-2px);}
  .board { display: flex; gap: 23px; width: 100%; align-items: flex-start; margin:1px auto 0 auto; justify-content:center; flex-wrap:wrap; min-height: 241px;}
  .column {
    background: var(--card); border-radius: var(--rounded); box-shadow: var(--shadow);
    width:100%;max-width:355px;min-width:205px; flex:1 1 265px; margin:0 0 32px 0;
    display:flex;flex-direction:column; max-height:78vh;overflow:auto; padding-bottom:2px;
  }
  .column h2 { font-size:1.14em; font-weight:700; color:var(--highlight); margin:16px 0 9px 0; letter-spacing:.9px;text-align:center;}
  .task {
    background: var(--task-gradient); color: #e3e6ed; margin: 11px 10px 21px 13px;
    padding: 11px 13px 14px 12px; border-radius: 10px; box-shadow:0 3px 12px #08102013,0 1.5px 2px #1926;
    position: relative; font-size:1.06em; border-left: 5px solid var(--accent-low); cursor:pointer;
    min-height:41px;display:flex;flex-direction:column;transition:all .17s;outline:2.6px solid transparent;
    max-width:96%;overflow:visible;box-shadow:0 2.5px 12px #1122;
  }
  .task:active {outline:2.6px solid var(--highlight);}
  .priority-high {border-left:6px solid var(--accent-high);}
  .priority-medium {border-left:6px solid var(--accent-medium);}
  .priority-low{border-left:5px solid var(--accent-low);}
  .task strong{ font-size:1.13em; }
  .selected-task { box-shadow: 0 0 12px 3px var(--highlight) !important; background-color: #1e2a59 !important; }
  .day-badge {
    display:inline-block; padding:3.5px 11px 3.5px 11px;
    border-radius:7px; color:#fff; font-size:.95em;font-weight:650;
    margin:0 7px 0 0; letter-spacing:.5px;position:relative;top:-2px;box-shadow:0 1.5px 6px #223d86cc;
  }
  .day-badge.today{background:#3399ff;}
  .day-badge.yesterday{background:#f39c12;}
  .day-badge.tomorrow{background:#21ce7e;}
  .task-tags {margin:0;display:flex;flex-wrap:wrap;gap:7px;}
  .tag{background:var(--tag);color:white;padding:3px 10px;border-radius:4px;font-size:0.92em;margin-right:3px;margin-bottom:1.2px;cursor:pointer;transition:opacity .15s;}
  .tag:hover{opacity:.73;}
  .tag-input{margin:3px 0 1px 0;padding:6px 7px;border-radius:5px;width:93%;font-size:1em;background:var(--input);color:var(--text);border:1px solid #252b3b;}
  .tag-input:focus{border-color:var(--highlight);}
  .dates{margin:6px 0 0 0;font-size:0.9em;color:#b2bede;}
  .delete-btn{
    position:absolute;top:6px;right:10px;background:var(--accent-high);
    border:none;border-radius:7px;color:#fff;font-weight:700;font-size:1.09em;
    padding:2px 10px;cursor:pointer;z-index:1;transition:background .13s;
    box-shadow:0 2px 10px #401a;outline:none;
  }
  .delete-btn:hover{background:#b13723;}
  .task-desc-form {
    margin:15px 2px 2px 0; padding:0;
    background:#161a23;
    border-radius:6px;
    box-shadow:0 2px 12px #3477;
    display:flex;flex-direction:column;align-items:flex-end;gap:6px;position:relative;
    z-index:9;
    width:95%;max-width:97%;
    animation: fadein .17s;
  }
  .task-desc-form textarea {
    width:98%; min-height:26px; font-size:1em; border-radius:5px; border:1px solid #298;
    background:#222938;color:#fff;padding:7px 7px;
    resize:vertical;box-shadow:0 2.5px 8px #3252;
  }
  .task-desc-form .desc-controls {
    display:flex;gap:9px;margin-right:3px;margin-bottom:7px;
  }
  .desc-save, .desc-cancel {
    background: var(--blue); color:#fff; font-size:.92em; border:none;
    border-radius:5px; padding:6px 15px; font-weight:700; cursor:pointer; box-shadow:0 1px 5px #366;
    transition:background .14s;
  }
  .desc-cancel { background: #d13a19;}
  .desc-save:hover {background: #198ddc;}
  .desc-cancel:hover {background:#bb281b;}
  #snackbar { visibility:hidden; min-width:170px; background:#383c4c; color:#f3c05c; text-align:left; border-radius:7px; padding:9px 18px; position:fixed;z-index:50; right:32px;bottom:36px;font-size:1em;font-weight:500; box-shadow:0 2px 12px #000a;}
  #snackbar.show{visibility:visible;animation:fadein 0.4s,fadeout 0.9s 2.3s;}
  #emptyNote {
    color: #ffc95c;
    background-color: #333844;
    padding: 12px 20px;
    border-radius: 10px;
    margin-bottom: 24px;
    text-align: center;
    font-weight: 600;
  }
  #privacyNotice {
    font-size: 0.9em;
    color: #999;
    text-align: center;
    padding: 10px;
    margin-top: 12px;
    user-select: none;
  }
  @keyframes fadein { from{bottom:0;opacity:0;} to{bottom:36px;opacity:1;} }
  @keyframes fadeout { from{bottom:36px;opacity:1;} to{bottom:0;opacity:0;} }
  #importFile{display:none;}
  @media (max-width:900px){
    .header-row{flex-direction:column;gap:7px;}
    .mini-btn{margin:0 auto 6px auto;}
    .task-form-container,form{max-width:99vw;}
    .search-box{margin-left:5vw;}
  }
  @media (max-width:680px){
    .header-row{flex-direction:column;}
    .kanban-wrap,.board{width:100vw;max-width:none;}
    .column{min-width:93vw;max-width:none;}
    .task{margin-left:3vw;margin-right:3vw;}
    .task-form-container,form{max-width:99vw;}
    .form-group{min-width:80vw;}
    input[type="text"],textarea,select{width:86vw;}
    #snackbar{right:5vw;min-width:91vw;}
    .search-box{margin-left:2vw;min-width:110px;}
  }
</style>
</head>
<body>
<div class="header-row">
  <div class="search-box">
    <label for="taskSearch" style="margin-right:5px;font-size:.92em;color:#88b0ec;">Search:</label>
    <input type="text" id="taskSearch" placeholder="/ Type to search tasks..." autocomplete="off" />
  </div>
  <div class="top-controls">
    <button class="mini-btn" id="toggleAddBoxBtn" title="Show or Hide Task Box (CTRL+ALT+N)">
      <svg fill="none" stroke="currentColor" stroke-width="2.2" viewBox="0 0 24 24"><path d="M12 5v14m7-7H5"/></svg>
    </button>
    <button class="mini-btn" id="exportBtn" title="Download Tasks (CTRL+O)">
      <svg fill="none" stroke="currentColor" stroke-width="2.2" viewBox="0 0 24 24"><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 9l5 5 5-5M12 4v12"/></svg>
    </button>
    <button class="mini-btn" id="importBtn" title="Restore Tasks (CTRL+R)">
      <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 20v-6m0 0l-4 4m4-4 4 4M4 4v6c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V4"/></svg>
    </button>
    <input type="file" id="importFile" accept=".json" />
  </div>
  <div class="board-title-wrap">
    <h1></h1>
  </div>
</div>
<div class="kanban-wrap">
  <div class="task-form-container" id="taskFormContainer" hidden>
    <form id="taskForm" autocomplete="off" novalidate>
      <div class="form-group" style="position: relative;">
        <label for="taskName">Task Name</label>
        <input type="text" id="taskName" placeholder="e.g. Review PR" required autocomplete="off" />
      </div>
      <div class="form-group">
        <label for="taskDescription">Description</label>
        <textarea id="taskDescription" placeholder="Describe your task"></textarea>
      </div>
      <div class="form-group">
        <label for="taskPriority">Priority</label>
        <select id="taskPriority">
          <option value="low">Low</option>
          <option value="medium">Medium</option>
          <option value="high">High</option>
        </select>
      </div>
      <div class="form-group" style="position: relative;">
        <label for="taskTags">Tags</label>
        <input type="text" id="taskTags" placeholder="Start typing tagsâ€¦" autocomplete="off"/>
      </div>
      <div class="form-group">
        <label for="taskColumn">Column</label>
        <select id="taskColumn">
          <option value="todo">To Do</option>
          <option value="inprogress">In Progress</option>
          <option value="done">Done</option>
        </select>
      </div>
      <button type="submit" class="add-btn-inner">Add Task</button>
    </form>
  </div>
  <div id="emptyNote" style="display:none;"></div>
  <div class="board">
    <div class="column" id="todo"><h2>To Do</h2></div>
    <div class="column" id="inprogress"><h2>In Progress</h2></div>
    <div class="column" id="done"><h2>Done</h2></div>
  </div>
</div>

<div id="snackbar"></div>
<div id="privacyNotice">
  Your data is yours. We do not sync, store, or keep your backup files. You control your own task data.
</div>
<script>
const columns = {
  todo: document.getElementById('todo'),
  inprogress: document.getElementById('inprogress'),
  done: document.getElementById('done')
};
function formatDate(date) {
  return date ? new Date(date).toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) : '';
}
function daysAgo(date) {
  return (new Date() - new Date(date)) / (1000 * 60 * 60 * 24);
}
function getDayLabel(date) {
  if (!date) return null;
  const d = new Date(date);
  const today = new Date();
  d.setHours(0,0,0,0); today.setHours(0,0,0,0);
  const oneDay = 24 * 60 * 60 * 1000;
  const diff = Math.floor((d - today) / oneDay);
  if (diff === 0) return { label: 'Today', class: 'today' };
  if (diff === -1) return { label: 'Yesterday', class: 'yesterday' };
  if (diff === 1) return { label: 'Tomorrow', class: 'tomorrow' };
  return null;
}
function saveTasks() {
  const allTasks = [];
  Object.entries(columns).forEach(([colKey, colElem]) => {
    [...colElem.children].forEach(taskElem => {
      if (taskElem.tagName === 'H2') return;
      allTasks.push({
        name: taskElem.dataset.name,
        description: taskElem.dataset.description,
        priority: taskElem.dataset.priority,
        tags: taskElem.dataset.tags,
        column: colKey,
        createdDate: taskElem.dataset.createdDate,
        movedDate: taskElem.dataset.movedDate
      });
    });
  });
  localStorage.setItem('kanbanTasks', JSON.stringify(allTasks));
  checkEmptyAndShowRestoreNote();
}
function loadTasks() {
  Object.values(columns).forEach(col => col.innerHTML = '<h2>' + col.querySelector('h2').textContent + '</h2>');
  try {
    const data = JSON.parse(localStorage.getItem('kanbanTasks')) || [];
    const recentTasks = data.filter(t => daysAgo(t.createdDate) <= 7);
    recentTasks.forEach(t => {
      const task = createTaskElement(t.name, t.description, t.priority, t.tags, t.column, t.createdDate, t.movedDate);
      columns[t.column].appendChild(task);
    });
  } catch(e) {console.error('Error loading tasks', e);}
  checkEmptyAndShowRestoreNote();
}
function displayTags(tagContainer, tags, onUpdate) {
  tagContainer.innerHTML = '';
  tags.forEach((tag, idx) => {
    const tagElem = document.createElement('span');
    tagElem.className = 'tag';
    tagElem.textContent = tag;
    tagElem.title = 'Click to remove tag';
    tagElem.onclick = () => {
      tags.splice(idx, 1);
      displayTags(tagContainer, tags, onUpdate);
      onUpdate(tags);
    };
    tagContainer.appendChild(tagElem);
  });
}
function showNotification(msg) {
  if (window.Notification && Notification.permission === "granted") {
    new Notification("Task Added", { body: msg });
  } else if (window.Notification && Notification.permission !== "denied") {
    Notification.requestPermission().then(permission => {
      if (permission === "granted") {
        new Notification("Task Added", { body: msg });
      }
    });
  }
  var snackbar = document.getElementById("snackbar");
  snackbar.textContent = msg;
  snackbar.className = "show";
  setTimeout(() => { snackbar.className = snackbar.className.replace("show", ""); }, 2600);
}
function createTaskElement(name, description, priority, tags, column, createdDate = null, movedDate = null) {
  const task = document.createElement('div');
  task.className = 'task priority-' + priority;
  task.draggable = true;
  const nowIso = new Date().toISOString();
  if (!createdDate) createdDate = nowIso;
  if (!movedDate) movedDate = nowIso;
  const tagArr = tags ? tags.split(',').map(t => t.trim()).filter(Boolean) : [];
  task.dataset.name = name;
  task.dataset.description = description || '';
  task.dataset.priority = priority;
  task.dataset.tags = tagArr.join(', ');
  task.dataset.createdDate = createdDate;
  task.dataset.movedDate = movedDate;
  const dayBadge = getDayLabel(createdDate);
  let dayLabelHtml = '';
  if (dayBadge) dayLabelHtml = `<span class="day-badge ${dayBadge.class}">${dayBadge.label}</span>`;

// Only visible info (no always visible description)
  task.innerHTML = `
    ${dayLabelHtml}<strong>${name}</strong>
    <button class="delete-btn" title="Delete task">&times;</button>
    <div class="task-tags"></div>
    <input class="tag-input" type="text" placeholder="Edit tags comma separated" style="display:none"/>
    <div class="dates">Created: ${formatDate(createdDate)} | Moved: ${formatDate(movedDate)} (${priority.charAt(0).toUpperCase()})</div>
  `;

  let descFormInstance = null;

  function removeDescForm() {
    document.querySelectorAll('.task-desc-form').forEach(f => f.remove());
    descFormInstance = null;
  }

  function showDescForm() {
    removeDescForm();
    descFormInstance = null;
    const form = document.createElement('div');
    form.className = 'task-desc-form';
    form.innerHTML = `
      <textarea>${task.dataset.description||''}</textarea>
      <div class="desc-controls">
        <button type="button" class="desc-save">Save</button>
        <button type="button" class="desc-cancel">Cancel</button>
      </div>
    `;
    form.querySelector('.desc-save').onclick = (event) => {
      const val = form.querySelector('textarea').value;
      task.dataset.description = val.trim();
      form.remove();
      descFormInstance = null;
      saveTasks();
      event.stopPropagation();
    };
    form.querySelector('.desc-cancel').onclick = (event) => {
      form.remove();
      descFormInstance = null;
      event.stopPropagation();
    };
    descFormInstance = form;
    task.appendChild(form);
    form.querySelector('textarea').focus();

    setTimeout(() => {
      window.addEventListener('mousedown', closeOnOutsideClick, { once: true });
    }, 20);
    function closeOnOutsideClick(e) {
      if (!task.contains(e.target)) {
        form.remove();
        descFormInstance = null;
      }
    }
  }
  
  task.addEventListener('click', function(e) {
    if (e.target.classList.contains('delete-btn') || e.target.classList.contains('tag') || e.target.classList.contains('task-tags')) return;
    if(!descFormInstance){
      showDescForm();
    }
  });

  // Tags
  const tagContainer = task.querySelector('.task-tags');
  displayTags(tagContainer, tagArr, newTags => {
    task.dataset.tags = newTags.join(', ');
    saveTasks();
  });
  tagContainer.title = 'Click to edit tags';
  const tagInput = task.querySelector('.tag-input');
  tagContainer.onclick = () => {
    tagInput.value = task.dataset.tags;
    tagInput.style.display = '';
    tagInput.focus();
  };
  tagInput.onblur = () => tagInput.style.display = 'none';
  tagInput.onkeydown = e => {
    if(e.key === 'Enter') {
      const tagList = tagInput.value.split(',').map(t => t.trim()).filter(Boolean);
      displayTags(tagContainer, tagList, newTags => {
        task.dataset.tags = newTags.join(', ');
        saveTasks();
      });
      tagInput.style.display = 'none';
      task.dataset.tags = tagList.join(', ');
      saveTasks();
    }
  };

  // Delete
  task.querySelector('.delete-btn').onclick = e => {
    e.stopPropagation();
    if(confirm(`Are you sure you want to delete "${task.dataset.name}"?`)){
      task.remove();
      saveTasks();
    }
  };

  task.addEventListener('dragstart', e => {
    e.dataTransfer.setData('text/plain', null);
    task.classList.add('dragging');
    window.draggedTask = task;
  });
  task.addEventListener('dragend', e => {
    task.classList.remove('dragging');
    window.draggedTask = null;
    task.dataset.movedDate = new Date().toISOString();
    task.querySelector('.dates').textContent =
      `Created: ${formatDate(task.dataset.createdDate)} | Moved: ${formatDate(task.dataset.movedDate)} (${task.dataset.priority.charAt(0).toUpperCase()})`;
    saveTasks();
  });

  return task;
}

Object.values(columns).forEach(col => {
  col.addEventListener('dragover', e => {
    e.preventDefault();
    const draggingTask = window.draggedTask;
    if (draggingTask) col.appendChild(draggingTask);
  });
});

document.getElementById('taskForm').addEventListener('submit', e => {
  e.preventDefault();
  const name = document.getElementById('taskName').value.trim();
  const description = document.getElementById('taskDescription').value.trim();
  const priority = document.getElementById('taskPriority').value;
  const tags = document.getElementById('taskTags').value;
  const column = document.getElementById('taskColumn').value;
  if (name) {
    const newTask = createTaskElement(name, description, priority, tags, column);
    columns[column].appendChild(newTask);
    showNotification(`"${name}" added to [${column}]${tags ? '\nTags: ' + tags : ''}`);
    e.target.reset();
    saveTasks();
    // Clear tag suggestions on add
    hideTagDropdown();
  }
});

document.getElementById('exportBtn').onclick = () => {
  const data = localStorage.getItem('kanbanTasks');
  const blob = new Blob([data], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'kanbanTasks.json'; a.click();
  URL.revokeObjectURL(url);
};

document.getElementById('importBtn').onclick = function() {
  document.getElementById('importFile').click();
};

document.getElementById('importFile').onchange = function(evt) {
  const file = evt.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const json = JSON.parse(e.target.result);
      if (!Array.isArray(json) || !json.every(t => t.name && t.column)) {
        alert('Error: Invalid file or content.');
        return;
      }
      localStorage.setItem('kanbanTasks', e.target.result);
      Object.values(columns).forEach(col => col.innerHTML = '<h2>' + col.querySelector('h2').textContent + '</h2>');
      loadTasks();
      showNotification('Kanban tasks have been restored!');
      checkEmptyAndShowRestoreNote();
    } catch (err) {
      alert('Error: Invalid file or content.');
    }
  };
  reader.readAsText(file);
};

// Toggle Add Task Box
const addBoxBtn = document.getElementById('toggleAddBoxBtn');
const taskFormBox = document.getElementById('taskFormContainer');
let addBoxVisible = false;
taskFormBox.hidden = true;
addBoxBtn.title = "Show or Hide Task Box (CTRL+ALT+N)";
addBoxBtn.onclick = () => {
  addBoxVisible = !addBoxVisible;
  taskFormBox.hidden = !addBoxVisible;
  addBoxBtn.title = addBoxVisible ? "Hide Add Task Box" : "Show or Hide Task Box";
};

// Search functionality with debounce
let searchTimeout = null;
document.getElementById('taskSearch').addEventListener('input', function(e){
  if(searchTimeout) clearTimeout(searchTimeout);
  const term = e.target.value.trim().toLowerCase();
  searchTimeout = setTimeout(() => {
    if(!term) {
      Object.values(columns).forEach(col => {
        [...col.children].forEach(taskElem => {
          if(taskElem.tagName === 'H2') return;
          taskElem.style.display = '';
        });
      });
      return;
    }
    Object.values(columns).forEach(col => {
      [...col.children].forEach(taskElem => {
        if (taskElem.tagName === 'H2') return;
        const name = (taskElem.dataset.name || '').toLowerCase();
        const desc = (taskElem.dataset.description || '').toLowerCase();
        const tags = (taskElem.dataset.tags || '').toLowerCase();
        let labelText = '';
        let dayBadgeEl = taskElem.querySelector('.day-badge');
        if (dayBadgeEl) labelText = dayBadgeEl.textContent.toLowerCase();
        if(name.includes(term) || desc.includes(term) || tags.includes(term) || labelText.includes(term)){
          taskElem.style.display = '';
        } else {
          taskElem.style.display = 'none';
        }
      });
    });
  }, 200);
});

// Keyboard shortcuts management
let selectedTask = null;

function getAllDisplayedTasks() {
  const allTasks = [];
  Object.values(columns).forEach(col => {
    [...col.children].forEach(task => {
      if (task.tagName === 'H2') return;
      if (task.style.display === 'none') return;
      allTasks.push(task);
    });
  });
  return allTasks;
}

function selectTask(task) {
  if (selectedTask) selectedTask.classList.remove('selected-task');
  selectedTask = task;
  if (task) task.classList.add('selected-task');
}

function selectNextTask() {
  const allTasks = getAllDisplayedTasks();
  if (allTasks.length === 0) return;
  let idx = selectedTask ? allTasks.indexOf(selectedTask) : -1;
  idx = Math.min(idx + 1, allTasks.length -1);
  selectTask(allTasks[idx]);
  selectedTask.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function selectPrevTask() {
  const allTasks = getAllDisplayedTasks();
  if (allTasks.length === 0) return;
  let idx = selectedTask ? allTasks.indexOf(selectedTask) : allTasks.length;
  idx = Math.max(idx - 1, 0);
  selectTask(allTasks[idx]);
  selectedTask.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function moveSelectedTaskRight() {
  if (!selectedTask) return;
  const colOrder = ['todo','inprogress','done'];
  let currentCol = selectedTask.parentElement.id;
  let idx = colOrder.indexOf(currentCol);
  if (idx === -1 || idx === colOrder.length - 1) return;
  columns[colOrder[idx + 1]].appendChild(selectedTask);
  selectedTask.dataset.movedDate = new Date().toISOString();
  selectedTask.querySelector('.dates').textContent =
    `Created: ${formatDate(selectedTask.dataset.createdDate)} | Moved: ${formatDate(selectedTask.dataset.movedDate)} (${selectedTask.dataset.priority.charAt(0).toUpperCase()})`;
  saveTasks();
}

function moveSelectedTaskLeft() {
  if (!selectedTask) return;
  const colOrder = ['todo','inprogress','done'];
  let currentCol = selectedTask.parentElement.id;
  let idx = colOrder.indexOf(currentCol);
  if (idx <= 0) return;
  columns[colOrder[idx - 1]].appendChild(selectedTask);
  selectedTask.dataset.movedDate = new Date().toISOString();
  selectedTask.querySelector('.dates').textContent =
    `Created: ${formatDate(selectedTask.dataset.createdDate)} | Moved: ${formatDate(selectedTask.dataset.movedDate)} (${selectedTask.dataset.priority.charAt(0).toUpperCase()})`;
  saveTasks();
}

function deleteSelectedTask() {
  if (!selectedTask) return;
  if(confirm(`Are you sure you want to delete "${selectedTask.dataset.name}"?`)){
    selectedTask.remove();
    saveTasks();
    selectedTask = null;
  }
}

function editSelectedTaskDescription() {
  if (!selectedTask) return;
  if (selectedTask.querySelector('.task-desc-form')) return; // already open
  selectedTask.click();
}

document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

  if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'n') {
    e.preventDefault();
    addBoxVisible = true;
    taskFormBox.hidden = false;
    addBoxBtn.title = "Hide Add Task Box";
    document.getElementById('taskName').focus();
  } else if (e.ctrlKey && e.key.toLowerCase() === 's') {
    e.preventDefault();
    document.getElementById('exportBtn').click();
  } else if (e.ctrlKey && e.key.toLowerCase() === 'o') {
    e.preventDefault();
    document.getElementById('importBtn').click();
  } else if (e.key === '/') {
    e.preventDefault();
    document.getElementById('taskSearch').focus();
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    selectNextTask();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    selectPrevTask();
  } else if (e.key === 'Enter') {
    if (selectedTask) {
      e.preventDefault();
      editSelectedTaskDescription();
    }
  } else if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selectedTask) {
      e.preventDefault();
      deleteSelectedTask();
    }
  } else if (e.ctrlKey && e.key === 'ArrowRight') {
    if (selectedTask) {
      e.preventDefault();
      moveSelectedTaskRight();
    }
  } else if (e.ctrlKey && e.key === 'ArrowLeft') {
    if (selectedTask) {
      e.preventDefault();
      moveSelectedTaskLeft();
    }
  }
});

// Show or hide note when all lists empty
function checkEmptyAndShowRestoreNote() {
  const allEmpty = Object.values(columns).every(col => [...col.children].filter(t => t.tagName !== 'H2').length === 0);
  const noteElem = document.getElementById('emptyNote');
  if (allEmpty) {
    noteElem.style.display = 'block';
    noteElem.textContent = 'All task lists are empty. You can restore tasks from a backup file using the Restore button above.';
  } else {
    noteElem.style.display = 'none';
  }
}

// Auto download backup JSON file
function autoDownloadBackup() {
  const data = localStorage.getItem('kanbanTasks');
  if (!data) return;
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'kanbanTasks_backup.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  console.log('Auto backup downloaded');
}

// Set interval to auto-download backup every 4 hours
setInterval(autoDownloadBackup, 4 * 60 * 60 * 1000); // every 4 hours

// Try to auto-download backup on browser close - may be blocked by some browsers
window.addEventListener('beforeunload', function () {
  saveTasks();
  autoDownloadBackup();
});

// Tag autocomplete dropdown logic
function getAllTags() {
  const tasks = JSON.parse(localStorage.getItem('kanbanTasks')) || [];
  const tagSet = new Set();
  tasks.forEach(t => {
    (t.tags || '').split(',').forEach(tag => {
      const trimmed = tag.trim();
      if (trimmed) tagSet.add(trimmed);
    });
  });
  return Array.from(tagSet).sort();
}

const tagInput = document.getElementById('taskTags');

const tagDropdown = document.createElement('div');
tagDropdown.style.position = 'absolute';
tagDropdown.style.background = '#222938';
tagDropdown.style.zIndex = '10';
tagDropdown.style.boxShadow = '0 2px 8px #1318';
tagDropdown.style.display = 'none';
tagDropdown.style.minWidth = '180px';
tagDropdown.style.borderRadius = '6px';
tagDropdown.style.padding = '6px 0';
tagDropdown.style.maxHeight = '170px';
tagDropdown.style.overflowY = 'auto';
tagDropdown.style.fontSize = '1em';
tagDropdown.style.color = '#cfe6fa';

tagInput.parentElement.appendChild(tagDropdown);

function hideTagDropdown() {
  tagDropdown.style.display = 'none';
}

tagInput.addEventListener('focus', showTagSuggestions);
tagInput.addEventListener('input', showTagSuggestions);

function showTagSuggestions() {
  const currentTags = tagInput.value.split(',').map(t => t.trim()).filter(Boolean);
  const allTags = getAllTags();
  const inputPart = tagInput.value.split(',').pop().trim().toLowerCase();
  const filtered = allTags.filter(tag => 
    tag.toLowerCase().startsWith(inputPart) &&
    !currentTags.includes(tag)
  );
  tagDropdown.innerHTML = '';
  if (filtered.length > 0 && inputPart !== '') {
    filtered.forEach(tag => {
      const item = document.createElement('div');
      item.textContent = tag;
      item.style.padding = '7px 15px';
      item.style.cursor = 'pointer';
      item.addEventListener('mousedown', e => {
        e.preventDefault();
        let tagsArr = tagInput.value.split(',').map(t => t.trim()).filter(Boolean);
        tagsArr.pop(); // remove current input part
        tagsArr.push(tag);
        tagInput.value = tagsArr.join(', ') + ', ';
        hideTagDropdown();
        tagInput.focus();
      });
      tagDropdown.appendChild(item);
    });
    tagDropdown.style.display = 'block';
    const rect = tagInput.getBoundingClientRect();
    tagDropdown.style.left = '0px';
    tagDropdown.style.top = `${tagInput.offsetHeight + 2}px`;
  } else {
    hideTagDropdown();
  }
}

tagInput.addEventListener('blur', () => setTimeout(() => hideTagDropdown(), 120));

// 30-minute notifications for To-Do and In-Progress
function notifyTaskSummary() {
  let allTasks = JSON.parse(localStorage.getItem('kanbanTasks')) || [];
  let pending = allTasks.filter(t => t.column === 'todo' || t.column === 'inprogress');
  if (pending.length > 0 && window.Notification && Notification.permission === "granted") {
    let body = pending.map(t => `[${t.column === 'todo' ? 'To-Do' : 'In Progress'}] ${t.name}`).join('\n');
    new Notification("Kanban Board Reminder", { body });
  } else if (window.Notification && Notification.permission !== "denied") {
    Notification.requestPermission();
  }
}

// Prompt notification permission on load and start the 30-min interval
window.addEventListener('load', () => {
  if (window.Notification && Notification.permission !== "granted") {
    Notification.requestPermission();
  }
  loadTasks();
  checkEmptyAndShowRestoreNote();
  setInterval(notifyTaskSummary, 30 * 60 * 1000); // every 30 mins
});
</script>
</body>
</html>
