<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kanban Board - Archive & Alarm Feature</title>
<link rel="manifest" href="manifest.json" />
<meta name="theme-color" content="#3399ff" />
<style>
  :root {
    --bg: #23242a;
    --card: #282934;
    --input: #25293c;
    --highlight: #3399ff;
    --text: #f4f7fa;
    --shadow: 0 4px 22px #112 35%;
    --accent-high: #e74c3c;
    --accent-medium: #f39c12;
    --accent-low: #2ecc71;
    --tag: #236bdd;
    --blue: #1d8bf1;
    --rounded: 13px;
    --task-gradient: linear-gradient(135deg, #293040 65%, #1d2130 100%);
  }
  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--text);
    font-family: 'Segoe UI',Tahoma,Verdana,sans-serif; min-height:100vh;
  }
  /* common styles omitted for brevity: add your existing styles here! */
  .board, #archiveBoard {
    display: flex; gap: 23px; width: 100%; align-items: flex-start; margin:1px auto 0 auto; justify-content:center; flex-wrap:wrap; min-height: 241px;
  }
  .archive-hidden {display:none;}
  .archive-visible {display:flex;}
  .alarm-picker input {
    font-size: 0.9em; color: #222; border-radius: 4px; padding: 3px 6px;
  }
  .alarm-picker button {
    background: var(--blue); color: white; border: none; cursor: pointer;
    border-radius: 5px; padding: 3px 7px; margin-left: 6px; font-weight: 600;
    font-size: 0.85em;
  }
  /* adapt your task style for alarm and popup */
</style>
</head>
<body>
<div class="header-row">
  <div class="search-box">
    <label for="taskSearch" style="margin-right:5px;font-size:.92em;color:#88b0ec;">Search:</label>
    <input type="text" id="taskSearch" placeholder="/ Type to search tasks..." autocomplete="off" />
  </div>
  <div class="top-controls">
    <button class="mini-btn" id="toggleAddBoxBtn" title="Show or Hide Task Box (CTRL+ALT+N)">
      <svg fill="none" stroke="currentColor" stroke-width="2.2" viewBox="0 0 24 24"><path d="M12 5v14m7-7H5"/></svg>
    </button>
    <button class="mini-btn" id="exportBtn" title="Download Tasks (CTRL+O)">
      <svg fill="none" stroke="currentColor" stroke-width="2.2" viewBox="0 0 24 24"><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 9l5 5 5-5M12 4v12"/></svg>
    </button>
    <button class="mini-btn" id="importBtn" title="Restore Tasks (CTRL+R)">
      <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 20v-6m0 0l-4 4m4-4 4 4M4 4v6c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V4"/></svg>
    </button>
    <input type="file" id="importFile" accept=".json" />
  </div>
  <div class="board-title-wrap" style="text-align:center; margin:12px 0;">
    <button id="showBoardBtn" class="mini-btn" style="margin-right:8px;">Show Board</button>
    <button id="showArchiveBtn" class="mini-btn">Show Archive</button>
  </div>
</div>

<div class="kanban-wrap">
  <div class="task-form-container" id="taskFormContainer" hidden>
    <form id="taskForm" autocomplete="off" novalidate>
      <div class="form-group">
        <label for="taskName">Task Name</label>
        <input type="text" id="taskName" placeholder="e.g. Review PR" required autocomplete="off" />
      </div>
      <div class="form-group">
        <label for="taskDescription">Description</label>
        <textarea id="taskDescription" placeholder="Describe your task"></textarea>
      </div>
      <div class="form-group">
        <label for="taskPriority">Priority</label>
        <select id="taskPriority">
          <option value="low">Low</option>
          <option value="medium">Medium</option>
          <option value="high">High</option>
        </select>
      </div>
      <div class="form-group">
        <label for="taskTags">Tags</label>
        <input type="text" id="taskTags" placeholder="Start typing tagsâ€¦" autocomplete="off"/>
      </div>
      <div class="form-group">
        <label for="taskColumn">Column</label>
        <select id="taskColumn">
          <option value="todo">To Do</option>
          <option value="inprogress">In Progress</option>
          <option value="done">Done</option>
        </select>
      </div>
      <button type="submit" class="add-btn-inner">Add Task</button>
    </form>
  </div>

  <div id="emptyNote" style="display:none; color:#ffc95c; background:#333844; padding:10px; text-align:center; border-radius:10px; margin-bottom:24px;"></div>

  <div class="board" id="boardView"></div>

  <div id="archiveView" style="display:none; width:98vw; max-width:1330px; margin:0 auto 1em auto;">
    <h2 style="text-align:center; color:var(--highlight); margin: 0.5em 0;">Archive (Older Than 7 Days)</h2>
    <div id="archiveBoard" style="display:flex; gap:20px; flex-wrap:wrap; justify-content:center;"></div>
  </div>
</div>

<div id="snackbar"></div>
<div id="privacyNotice" style="font-size:0.9em;color:#999;text-align:center;padding:10px;margin-top:12px;user-select:none;">
  Your data is yours. We do not sync, store, or keep your backup files. You control your own task data.
</div>

<script>
const columns = {};
const columnIds = ['todo', 'inprogress', 'done'];
columnIds.forEach(id => {
  columns[id] = document.createElement('div');
  columns[id].className = 'column';
  columns[id].id = id;
  const header = document.createElement('h2');
  header.textContent = id.charAt(0).toUpperCase() + id.slice(1).replace(/([A-Z])/g, ' $1');
  columns[id].appendChild(header);
});

// Append columns to board container
const boardView = document.getElementById('boardView');
columnIds.forEach(id => boardView.appendChild(columns[id]));
boardView.style.display = 'flex';

// Archive container
const archiveBoard = document.getElementById('archiveBoard');

function formatDate(date) {
  return date ? new Date(date).toLocaleDateString(undefined, { month: 'short', day: 'numeric', hour:'2-digit', minute:'2-digit' }) : '';
}
function daysAgo(date) {
  return (new Date() - new Date(date)) / (1000 * 60 * 60 * 24);
}

function createTaskElement(name, description, priority, tags, column, createdDate = null, movedDate = null, alarmDate = '') {
  const task = document.createElement('div');
  task.className = 'task priority-' + priority;
  task.draggable = true;
  const nowIso = new Date().toISOString();
  if (!createdDate) createdDate = nowIso;
  if (!movedDate) movedDate = nowIso;
  const tagArr = tags ? tags.split(',').map(t => t.trim()).filter(Boolean) : [];
  task.dataset.name = name;
  task.dataset.description = description || '';
  task.dataset.priority = priority;
  task.dataset.tags = tagArr.join(', ');
  task.dataset.createdDate = createdDate;
  task.dataset.movedDate = movedDate;
  task.dataset.alarmDate = alarmDate;
  task.dataset.alarmNotified = "false";

  const dayBadge = getDayLabel(createdDate);
  let dayLabelHtml = '';
  if (dayBadge) dayLabelHtml = `<span class="day-badge ${dayBadge.class}">${dayBadge.label}</span>`;

  task.innerHTML = `
    ${dayLabelHtml}<strong>${name}</strong>
    <button class="delete-btn" title="Delete task">&times;</button>
    <div class="task-tags"></div>
    <input class="tag-input" type="text" placeholder="Edit tags comma separated" style="display:none"/>
    <div class="dates">Created: ${formatDate(createdDate)} | Moved: ${formatDate(movedDate)} (${priority.charAt(0).toUpperCase()})</div>
    <div class="task-alarm" style="margin-top:8px; font-size:0.9em; color:#93d7ff; display:flex; align-items:center; gap:6px; cursor:pointer;">
      <svg style="width:16px;height:16px; fill:#93d7ff;" viewBox="0 0 24 24"><path d="M12 7v5l4 2"/></svg>
      <span class="alarm-text">${alarmDate ? new Date(alarmDate).toLocaleString() : 'Set Alarm'}</span>
    </div>
  `;

  let descFormInstance = null;

  function removeDescForm() {
    document.querySelectorAll('.task-desc-form').forEach(f => f.remove());
    descFormInstance = null;
  }

  function showDescForm() {
    removeDescForm();
    descFormInstance = null;
    const form = document.createElement('div');
    form.className = 'task-desc-form';
    form.innerHTML = `
      <textarea>${task.dataset.description||''}</textarea>
      <div class="desc-controls">
        <button type="button" class="desc-save">Save</button>
        <button type="button" class="desc-cancel">Cancel</button>
      </div>
    `;
    form.querySelector('.desc-save').onclick = (event) => {
      const val = form.querySelector('textarea').value;
      task.dataset.description = val.trim();
      form.remove();
      descFormInstance = null;
      saveTasks();
      event.stopPropagation();
    };
    form.querySelector('.desc-cancel').onclick = (event) => {
      form.remove();
      descFormInstance = null;
      event.stopPropagation();
    };
    descFormInstance = form;
    task.appendChild(form);
    form.querySelector('textarea').focus();

    setTimeout(() => {
      window.addEventListener('mousedown', closeOnOutsideClick, { once: true });
    }, 20);
    function closeOnOutsideClick(e) {
      if (!task.contains(e.target)) {
        form.remove();
        descFormInstance = null;
      }
    }
  }

  task.addEventListener('click', function(e) {
    if (e.target.classList.contains('delete-btn') || e.target.classList.contains('tag') || e.target.classList.contains('task-tags') || e.target.closest('.task-alarm')) return;
    if(!descFormInstance){
      showDescForm();
    }
  });

  // Tags
  const tagContainer = task.querySelector('.task-tags');
  displayTags(tagContainer, tagArr, newTags => {
    task.dataset.tags = newTags.join(', ');
    saveTasks();
  });
  tagContainer.title = 'Click to edit tags';
  const tagInput = task.querySelector('.tag-input');
  tagContainer.onclick = () => {
    tagInput.value = task.dataset.tags;
    tagInput.style.display = '';
    tagInput.focus();
  };
  tagInput.onblur = () => tagInput.style.display = 'none';
  tagInput.onkeydown = e => {
    if(e.key === 'Enter') {
      const tagList = tagInput.value.split(',').map(t => t.trim()).filter(Boolean);
      displayTags(tagContainer, tagList, newTags => {
        task.dataset.tags = newTags.join(', ');
        saveTasks();
      });
      tagInput.style.display = 'none';
      task.dataset.tags = tagList.join(', ');
      saveTasks();
    }
  };

  // Delete
  task.querySelector('.delete-btn').onclick = e => {
    e.stopPropagation();
    if(confirm(`Are you sure you want to delete "${task.dataset.name}"?`)){
      task.remove();
      saveTasks();
    }
  };

  // Alarm UI handler
  const alarmDiv = task.querySelector('.task-alarm');
  alarmDiv.onclick = (e) => {
    e.stopPropagation();
    if (task.querySelector('.alarm-picker')) {
      task.querySelector('.alarm-picker').remove();
    } else {
      const pickerDiv = document.createElement('div');
      pickerDiv.className = 'alarm-picker';

      pickerDiv.style.marginTop = '6px';
      pickerDiv.style.display = 'flex';
      pickerDiv.style.alignItems = 'center';
      pickerDiv.style.gap = '6px';

      pickerDiv.innerHTML = `
        <input type="datetime-local" value="${alarmDate ? alarmDate.substring(0,16) : ''}" />
        <button>Save</button>
        <button>Clear</button>
      `;

      pickerDiv.querySelector('button').onclick = () => {
        const input = pickerDiv.querySelector('input').value;
        task.dataset.alarmDate = input ? new Date(input).toISOString() : '';
        task.dataset.alarmNotified = "false";
        task.querySelector('.alarm-text').textContent = input ? new Date(input).toLocaleString() : 'Set Alarm';
        pickerDiv.remove();
        saveTasks();
      };

      pickerDiv.querySelectorAll('button')[1].onclick = () => {
        task.dataset.alarmDate = '';
        task.dataset.alarmNotified = "false";
        task.querySelector('.alarm-text').textContent = 'Set Alarm';
        pickerDiv.remove();
        saveTasks();
      };

      task.appendChild(pickerDiv);
    }
  };

  // Drag events
  task.addEventListener('dragstart', e => {
    e.dataTransfer.setData('text/plain', null);
    task.classList.add('dragging');
    window.draggedTask = task;
  });
  task.addEventListener('dragend', e => {
    task.classList.remove('dragging');
    window.draggedTask = null;
    task.dataset.movedDate = new Date().toISOString();
    task.querySelector('.dates').textContent =
      `Created: ${formatDate(task.dataset.createdDate)} | Moved: ${formatDate(task.dataset.movedDate)} (${task.dataset.priority.charAt(0).toUpperCase()})`;
    saveTasks();
  });

  return task;
}

Object.values(columns).forEach(col => {
  col.addEventListener('dragover', e => {
    e.preventDefault();
    const draggingTask = window.draggedTask;
    if (draggingTask) col.appendChild(draggingTask);
  });
});

function displayTags(tagContainer, tags, onUpdate) {
  tagContainer.innerHTML = '';
  tags.forEach((tag, idx) => {
    const tagElem = document.createElement('span');
    tagElem.className = 'tag';
    tagElem.textContent = tag;
    tagElem.title = 'Click to remove tag';
    tagElem.onclick = () => {
      tags.splice(idx, 1);
      displayTags(tagContainer, tags, onUpdate);
      onUpdate(tags);
    };
    tagContainer.appendChild(tagElem);
  });
}

function getDayLabel(date) {
  if (!date) return null;
  const d = new Date(date);
  const today = new Date();
  d.setHours(0,0,0,0); today.setHours(0,0,0,0);
  const oneDay = 24 * 60 * 60 * 1000;
  const diff = Math.floor((d - today) / oneDay);
  if (diff === 0) return { label: 'Today', class: 'today' };
  if (diff === -1) return { label: 'Yesterday', class: 'yesterday' };
  if (diff === 1) return { label: 'Tomorrow', class: 'tomorrow' };
  return null;
}

function saveTasks() {
  const allTasks = [];
  Object.values(columns).forEach(col => {
    [...col.children].forEach(task => {
      if (task.tagName === 'H2') return;
      allTasks.push({
        name: task.dataset.name,
        description: task.dataset.description,
        priority: task.dataset.priority,
        tags: task.dataset.tags,
        column: col.id,
        createdDate: task.dataset.createdDate,
        movedDate: task.dataset.movedDate,
        alarmDate: task.dataset.alarmDate || ''
      });
    });
  });
  [...archiveBoard.children].forEach(task => {
    if (task.tagName === 'H2') return;
    allTasks.push({
      name: task.dataset.name,
      description: task.dataset.description,
      priority: task.dataset.priority,
      tags: task.dataset.tags,
      column: task.dataset.column || 'archived',
      createdDate: task.dataset.createdDate,
      movedDate: task.dataset.movedDate,
      alarmDate: task.dataset.alarmDate || ''
    });
  });
  localStorage.setItem('kanbanTasks', JSON.stringify(allTasks));
  checkEmptyAndShowRestoreNote();
}

function loadTasks() {
  Object.values(columns).forEach(col => col.innerHTML = '<h2>' + col.querySelector('h2').textContent + '</h2>');
  archiveBoard.innerHTML = '';
  try {
    const data = JSON.parse(localStorage.getItem('kanbanTasks')) || [];
    data.forEach(t => {
      const isOld = daysAgo(t.createdDate) > 7;
      const task = createTaskElement(t.name, t.description, t.priority, t.tags, t.column, t.createdDate, t.movedDate, t.alarmDate || '');
      if (isOld) {
        archiveBoard.appendChild(task);
        task.dataset.column = 'archived';
      } else {
        columns[t.column].appendChild(task);
      }
    });
  } catch(e) { console.error('Error loading tasks', e); }
  checkEmptyAndShowRestoreNote();
}

function checkEmptyAndShowRestoreNote() {
  const allEmpty = Object.values(columns).every(col => [...col.children].filter(t => t.tagName !== 'H2').length === 0);
  const noteElem = document.getElementById('emptyNote');
  if (allEmpty) {
    noteElem.style.display = 'block';
    noteElem.textContent = 'All task lists are empty. You can restore tasks from a backup file using the Restore button above.';
  } else {
    noteElem.style.display = 'none';
  }
}

function autoDownloadBackup() {
  const data = localStorage.getItem('kanbanTasks');
  if (!data) return;
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'kanbanTasks_backup.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  console.log('Auto backup downloaded');
}

setInterval(autoDownloadBackup, 4 * 60 * 60 * 1000);

window.addEventListener('beforeunload', () => {
  saveTasks();
  autoDownloadBackup();
});

document.getElementById('exportBtn').onclick = () => {
  const data = localStorage.getItem('kanbanTasks');
  const blob = new Blob([data], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'kanbanTasks.json'; a.click();
  URL.revokeObjectURL(url);
};

document.getElementById('importBtn').onclick = () => {
  document.getElementById('importFile').click();
};

document.getElementById('importFile').onchange = function(evt) {
  const file = evt.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const json = JSON.parse(e.target.result);
      if (!Array.isArray(json) || !json.every(t => t.name && t.column)) {
        alert('Error: Invalid file or content.');
        return;
      }
      localStorage.setItem('kanbanTasks', e.target.result);
      loadTasks();
      showNotification('Kanban tasks have been restored!');
      checkEmptyAndShowRestoreNote();
    } catch (err) {
      alert('Error: Invalid file or content.');
    }
  };
  reader.readAsText(file);
};

const addBoxBtn = document.getElementById('toggleAddBoxBtn');
const taskFormBox = document.getElementById('taskFormContainer');
let addBoxVisible = false;
taskFormBox.hidden = true;
addBoxBtn.title = "Show or Hide Task Box (CTRL+ALT+N)";
addBoxBtn.onclick = () => {
  addBoxVisible = !addBoxVisible;
  taskFormBox.hidden = !addBoxVisible;
  addBoxBtn.title = addBoxVisible ? "Hide Add Task Box" : "Show or Hide Task Box";
};

let selectedTask = null;

function getAllDisplayedTasks() {
  const allTasks = [];
  Object.values(columns).forEach(col => {
    [...col.children].forEach(task => {
      if (task.tagName === 'H2') return;
      if (task.style.display === 'none') return;
      allTasks.push(task);
    });
  });
  return allTasks;
}

function selectTask(task) {
  if (selectedTask) selectedTask.classList.remove('selected-task');
  selectedTask = task;
  if (task) task.classList.add('selected-task');
}

function selectNextTask() {
  const allTasks = getAllDisplayedTasks();
  if (allTasks.length === 0) return;
  let idx = selectedTask ? allTasks.indexOf(selectedTask) : -1;
  idx = Math.min(idx + 1, allTasks.length -1);
  selectTask(allTasks[idx]);
  selectedTask.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function selectPrevTask() {
  const allTasks = getAllDisplayedTasks();
  if (allTasks.length === 0) return;
  let idx = selectedTask ? allTasks.indexOf(selectedTask) : allTasks.length;
  idx = Math.max(idx - 1, 0);
  selectTask(allTasks[idx]);
  selectedTask.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function moveSelectedTaskRight() {
  if (!selectedTask) return;
  const colOrder = ['todo','inprogress','done'];
  let currentCol = selectedTask.parentElement.id;
  let idx = colOrder.indexOf(currentCol);
  if (idx === -1 || idx === colOrder.length - 1) return;
  columns[colOrder[idx + 1]].appendChild(selectedTask);
  selectedTask.dataset.movedDate = new Date().toISOString();
  selectedTask.querySelector('.dates').textContent =
    `Created: ${formatDate(selectedTask.dataset.createdDate)} | Moved: ${formatDate(selectedTask.dataset.movedDate)} (${selectedTask.dataset.priority.charAt(0).toUpperCase()})`;
  saveTasks();
}

function moveSelectedTaskLeft() {
  if (!selectedTask) return;
  const colOrder = ['todo','inprogress','done'];
  let currentCol = selectedTask.parentElement.id;
  let idx = colOrder.indexOf(currentCol);
  if (idx <= 0) return;
  columns[colOrder[idx - 1]].appendChild(selectedTask);
  selectedTask.dataset.movedDate = new Date().toISOString();
  selectedTask.querySelector('.dates').textContent =
    `Created: ${formatDate(selectedTask.dataset.createdDate)} | Moved: ${formatDate(selectedTask.dataset.movedDate)} (${selectedTask.dataset.priority.charAt(0).toUpperCase()})`;
  saveTasks();
}

function deleteSelectedTask() {
  if (!selectedTask) return;
  if(confirm(`Are you sure you want to delete "${selectedTask.dataset.name}"?`)){
    selectedTask.remove();
    saveTasks();
    selectedTask = null;
  }
}

function editSelectedTaskDescription() {
  if (!selectedTask) return;
  if (selectedTask.querySelector('.task-desc-form')) return; // already open
  selectedTask.click();
}

document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

  if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'n') {
    e.preventDefault();
    addBoxVisible = true;
    taskFormBox.hidden = false;
    addBoxBtn.title = "Hide Add Task Box";
    document.getElementById('taskName').focus();
  } else if (e.ctrlKey && e.key.toLowerCase() === 's') {
    e.preventDefault();
    document.getElementById('exportBtn').click();
  } else if (e.ctrlKey && e.key.toLowerCase() === 'o') {
    e.preventDefault();
    document.getElementById('importBtn').click();
  } else if (e.key === '/') {
    e.preventDefault();
    document.getElementById('taskSearch').focus();
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    selectNextTask();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    selectPrevTask();
  } else if (e.key === 'Enter') {
    if (selectedTask) {
      e.preventDefault();
      editSelectedTaskDescription();
    }
  } else if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selectedTask) {
      e.preventDefault();
      deleteSelectedTask();
    }
  } else if (e.ctrlKey && e.key === 'ArrowRight') {
    if (selectedTask) {
      e.preventDefault();
      moveSelectedTaskRight();
    }
  } else if (e.ctrlKey && e.key === 'ArrowLeft') {
    if (selectedTask) {
      e.preventDefault();
      moveSelectedTaskLeft();
    }
  }
});

// Show or hide note when all lists empty
function checkEmptyAndShowRestoreNote() {
  const allEmpty = Object.values(columns).every(col => [...col.children].filter(t => t.tagName !== 'H2').length === 0);
  // Exclude archive from this check; may show note when board empty only
  const noteElem = document.getElementById('emptyNote');
  if (allEmpty) {
    noteElem.style.display = 'block';
    noteElem.textContent = 'All task lists are empty. You can restore tasks from a backup file using the Restore button above.';
  } else {
    noteElem.style.display = 'none';
  }
}

// Auto backup every 4 hours
function autoDownloadBackup() {
  const data = localStorage.getItem('kanbanTasks');
  if (!data) return;
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'kanbanTasks_backup.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  console.log('Auto backup downloaded');
}

setInterval(autoDownloadBackup, 4 * 60 * 60 * 1000);

window.addEventListener('beforeunload', () => {
  saveTasks();
  autoDownloadBackup();
});

// Alarm notifications
function checkAlarms() {
  const now = new Date();
  [...boardView.children, ...archiveBoard.children].forEach(task => {
    if (task.tagName === 'H2') return;
    const alarmDateStr = task.dataset.alarmDate;
    if (alarmDateStr && task.dataset.alarmNotified !== 'true') {
      const alarmDate = new Date(alarmDateStr);
      if (alarmDate <= now) {
        if (window.Notification && Notification.permission === "granted") {
          new Notification("Kanban Task Alarm", {
            body: `Alarm for task "${task.dataset.name}" reached at ${alarmDate.toLocaleString()}`,
          });
          task.dataset.alarmNotified = "true";
        }
      }
    }
  });
}
setInterval(checkAlarms, 60 * 1000);

// Notification summary every 30 mins for todo and inprogress
function notifyTaskSummary() {
  let allTasks = JSON.parse(localStorage.getItem('kanbanTasks')) || [];
  let pending = allTasks.filter(t => t.column === 'todo' || t.column === 'inprogress');
  if (pending.length > 0 && window.Notification && Notification.permission === "granted") {
    let body = pending.map(t => `[${t.column === 'todo' ? 'To-Do' : 'In Progress'}] ${t.name}`).join('\n');
    new Notification("Kanban Board Reminder", { body });
  } else if (window.Notification && Notification.permission !== "denied") {
    Notification.requestPermission();
  }
}

window.addEventListener('load', () => {
  if (window.Notification && Notification.permission !== "granted") {
    Notification.requestPermission();
  }
  loadTasks();
  checkEmptyAndShowRestoreNote();
  setInterval(notifyTaskSummary, 30 * 60 * 1000);
});

// Toggle board/archive views
document.getElementById('showBoardBtn').onclick = () => {
  boardView.style.display = 'flex';
  document.getElementById('archiveView').style.display = 'none';
  document.getElementById('emptyNote').style.display = 'none';
};
document.getElementById('showArchiveBtn').onclick = () => {
  boardView.style.display = 'none';
  document.getElementById('archiveView').style.display = 'block';
  document.getElementById('emptyNote').style.display = 'none';
};

// Include your previously implemented tag autocomplete code here (if still needed)...

</script>
</body>
</html>
